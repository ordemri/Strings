contract LazyStringBuilder {
    
    bytes[] a;  
    uint index = 0;
    bytes  cache;
    uint cacheIndex = 0;


    
    function append(string str){
       bytes memory n = bytes(str);
        if(n.length > 0){
            a.push(n);
            index += n.length;
            delete n;
        } else {
            throw;
        }
    }
    
    function toString() returns (string){
        if (index > 0){
            if (cacheIndex != a.length){
            uint c = 0;
            bytes memory b = new bytes(index);
            if(cacheIndex > 0){
                for(uint i1 =0;i1<cache.length;i1++){
                  b[c] = cache[c];   
                  c++;
                }
            }
            for(uint i = cacheIndex; i < a.length ; i ++){
                for(uint j =0; j < a[i].length; j ++){
                    b[c++] = a[i][j];
                }    
            }
            cache = b;
            cacheIndex = a.length;
            delete b;
            }
        return string (cache);
        }
        else {
            return "";
        }
    }
    
}
library StringUtils{
        function substr(string text, uint start, uint end) private returns (string){
        bytes memory d = bytes(text);
        bytes memory  b = new bytes(end-start);
        for(uint i = start; i<end;i++){
            b[i - start]=d[i];
        }
        return string(b);
    }
    
    function indexOf(string _haystack, string _needle) returns (int){
        return indexOf(_haystack,_needle,0);
    }
    
    function indexOf(string _haystack, string _needle,uint _start) private returns (int)
    {
        bytes memory h = bytes(_haystack);
        bytes memory n = bytes(_needle);
        if(h.length < 1 || n.length < 1 || (n.length > h.length)) 
            return -1;
        else if(h.length > (2**128 -1)) 
            return -1;                                  
        else
        {
            uint subindex = 0;
            for (uint i = _start; i < h.length; i ++)
            {
                if (h[i] == n[0]) 
                {
                    subindex = 1;
                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])
                    {
                        subindex++;
                    }   
                    if(subindex == n.length)
                        return int(i);
                }
            }
            return -1;
        }   
    
        }
    
}